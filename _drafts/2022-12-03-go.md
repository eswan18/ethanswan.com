---
layout: post
date: 2022-12-03
tags:
- tech
- go
- programming languages
title: I Go, You Go, We All Go for Nice Go
excerpt: "After spending the first six years of my career specializing in Python, both in and out of work, I made a big jump this year to a new job and new languages. Iâ€™ve spent a lot of time with Go in particular..."
preview_image: ""
---

After spending the first six years of my career specializing in Python, both in and out of work, I made a big jump this year to a new job and new languages.
I've spent a lot of time with Go in particular.
Now that I've been using it regularly for over six months, I'm starting to feel like my views of the language have graduated from uneducated hot takes to cautious opinions with a bit of nuance, and -- even though I know these views will change with time -- I wanted to talk about the things I like and don't like about Go so far.

## Error Handling
We might as well get it out of the way, because error handling is clearly the most contentious aspect of Go.

For my first few months, I just hated it.
There is no mechanism built into the language specifically for exception handling.
In other languages I know, like Python, JavaScript, and Ruby, there are language keywords to "raise" or "throw" an error.
Errors flow differently than regular data; if not "handled", they rise up through the entire function stack and crash the program.
Developers are encouraged to write code to anticipate those exceptions, handle them before everything explodes, and change the logic flow of the program accordingly.

What exactly needs to be done in that "handling" step typically depends on what went wrong, and so there are many types of errors.
Programmers can check the type of an error to determine what went wrong and react accordingly.
Developers sometimes even create their own types of errors, to signal issues that arise in the logic they wrote.
Errors can be thought of as objects and their types as classes that can be subclassed like any other class.
But they follow a different path through the code than other variables, in that they progressively short-circuit functions one at a time up the function stack until handled.

I started writing a full overview of errors in Python as a way to draw a contrast with Go's approach, but that turned out long enough that I spun it into a separate article.
If you don't know anything about try/except style error handling with stack traces, hop over [here](/feed/2022/12/04/python-exceptions) to see an example.

