---
layout: post
date: 2022-12-03
tags:
- tech
- go
- programming languages
title: I Go, You Go, We All Go for Nice Go
excerpt: "After spending the first six years of my career specializing in Python, both in and out of work, I made a big jump this year to a new job and new languages. Iâ€™ve spent a lot of time with Go in particular..."
preview_image: ""
---

After spending the first six years of my career specializing in Python, both in and out of work, I made a big jump this year to a new job and new languages.
I've spent a lot of time with Go in particular.
Now that I've been using it regularly for over six months, I'm starting to feel like my views of the language have graduated from uneducated hot takes to cautious opinions with a bit of nuance, and -- even though I know these views will change with time -- I wanted to talk about the things I like and don't like about Go so far.

## Error Handling
We might as well get it out of the way:
error handling is clearly the most contentious aspect of Go.

For my first few months, I just hated it.
There is no mechanism built into the language specifically for exception handling.
In other languages I know, like Python, JavaScript, and Ruby, there are language keywords to "raise" or "throw" an error.
(This pattern seems pretty common across popular languages.)

Here's a simplified example of how you might raise an exception in Python.

```python
def divide(x, y):
    if y == 0:
        raise Exception("Can't divide by zero")
    return x / y
```

The interesting thing here is that the `raise` keyword actually causes the function to exit prematurely;
the line `return x / y` never executes if `y` is 0.
If you run this code in Python, you'll see that error show up:

```text
>>> divide(3, 0)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "<stdin>", line 3, in divide
Exception: Can't divide by zero
```

The exception isn't *returned* from the function, it's propagated via an entirely different pathway.
You can see this a few ways -- one is by trying to assign the result of `divide` to a variable.

```text
>>> x = divide(3, 0)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "<stdin>", line 3, in divide
Exception: Can't divide by zero
>>> x
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
NameError: name 'x' is not defined
```

The error short-circuits the function, and the code never finishes.
No value is returned, so the variable is never set.

If `divide` is called within another function, the error will rise through both layers and short-circuit the calling function as well.

```python
def calculate_percent(numerator, denominator):
    raw_quotient = divide(numerator, denominator)
    return 100 * raw_quotient
```
```text
>>> calculate_percent(10, 0)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "<stdin>", line 2, in calculate_percent
  File "<stdin>", line 3, in divide
Exception: Can't divide by zero
```

You can see what's called the "stack trace" of the error as it bubbles up from its origin (the `raise` line in `divide`) up through `calculate_percent` and finally into `<module>` (which is actually the Python REPL).
Having a stack trace is extremely helpful; `divide` could be called multiple times in our program, but with this knowledge we can quickly understand the exact provenance of the error and know where to look in order to fix it.